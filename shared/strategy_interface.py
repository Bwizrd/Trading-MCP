#!/usr/bin/env python3
"""
Strategy Interface Pattern - Abstract Base Classes

This module defines the "game cartridge" interfaces for trading strategies.
Strategies implement these interfaces to work with the universal backtest engine.

Phase 1 of gradual migration - new interfaces alongside existing code.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Union
from datetime import datetime, time
from dataclasses import dataclass
from enum import Enum

from shared.models import Candle, TradeDirection, TradeResult, Trade


class SignalStrength(Enum):
    """Signal strength levels for trading signals."""
    WEAK = 0.3
    MODERATE = 0.5
    STRONG = 0.7
    VERY_STRONG = 0.9


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    This is the standardized output that all strategies must produce.
    """
    direction: TradeDirection
    price: float
    strength: SignalStrength
    confidence: float  # 0.0 to 1.0
    reason: str
    timestamp: datetime
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class StrategyContext:
    """
    Context information available to strategies when generating signals.
    
    Contains all the historical and current market information a strategy
    might need to make decisions.
    """
    current_candle: Candle
    historical_candles: List[Candle]
    indicators: Dict[str, float]  # Pre-calculated indicators (VWAP, SMA, etc.)
    current_position: Optional['Trade'] = None
    market_session: str = "unknown"  # "london", "new_york", etc.
    symbol: str = ""
    timeframe: str = ""
    
    def get_indicator(self, name: str, default: float = None) -> Optional[float]:
        """Get indicator value with optional default."""
        return self.indicators.get(name, default)
    
    def get_previous_candles(self, count: int) -> List[Candle]:
        """Get the last N candles from history."""
        return self.historical_candles[-count:] if count <= len(self.historical_candles) else self.historical_candles


@dataclass
class StrategyParameters:
    """
    Configuration parameters for a strategy.
    
    Each strategy defines its own parameters with defaults.
    """
    name: str
    parameters: Dict[str, Any]
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get parameter value with optional default."""
        return self.parameters.get(key, default)
    
    def set(self, key: str, value: Any) -> None:
        """Set parameter value."""
        self.parameters[key] = value


class TradingStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    This is the "cartridge slot" that defines the interface every strategy
    must implement to work with the universal backtest engine.
    
    Each strategy is like a game cartridge that plugs into the console.
    """
    
    def __init__(self):
        self._parameters = StrategyParameters(
            name=self.get_name(),
            parameters=self.get_default_parameters()
        )
        self._initialized = False
    
    @abstractmethod
    def get_name(self) -> str:
        """
        Return the strategy name.
        
        Returns:
            str: Human-readable strategy name (e.g., "VWAP Reversal", "MA Crossover")
        """
        pass
    
    @abstractmethod
    def get_description(self) -> str:
        """
        Return strategy description.
        
        Returns:
            str: Detailed description of how the strategy works
        """
        pass
    
    @abstractmethod
    def get_version(self) -> str:
        """
        Return strategy version.
        
        Returns:
            str: Version string (e.g., "1.0.0")
        """
        pass
    
    @abstractmethod
    def get_default_parameters(self) -> Dict[str, Any]:
        """
        Return default strategy parameters.
        
        Returns:
            Dict[str, Any]: Dictionary of parameter names and default values
        """
        pass
    
    @abstractmethod 
    def requires_indicators(self) -> List[str]:
        """
        Return list of required technical indicators.
        
        Returns:
            List[str]: List of indicator names (e.g., ["VWAP", "SMA20", "RSI"])
        """
        pass
    
    @abstractmethod
    def generate_signal(self, context: StrategyContext) -> Optional[Signal]:
        """
        Generate trading signal based on current market context.
        
        This is the core method that defines the strategy logic.
        
        Args:
            context: Current market context with candles, indicators, position info
            
        Returns:
            Signal: Trading signal or None if no signal should be generated
        """
        pass
    
    def initialize(self, parameters: Dict[str, Any] = None) -> None:
        """
        Initialize strategy with custom parameters.
        
        Args:
            parameters: Optional custom parameters to override defaults
        """
        if parameters:
            self._parameters.parameters.update(parameters)
        
        self._validate_parameters()
        self._initialized = True
    
    def _validate_parameters(self) -> None:
        """
        Validate strategy parameters.
        
        Override this method to add custom parameter validation.
        """
        pass
    
    def get_parameters(self) -> StrategyParameters:
        """Get current strategy parameters."""
        return self._parameters
    
    def is_initialized(self) -> bool:
        """Check if strategy has been initialized."""
        return self._initialized
    
    # Optional callback methods
    def on_trade_opened(self, trade: 'Trade', context: StrategyContext) -> None:
        """
        Called when a trade is opened based on this strategy's signal.
        
        Override this method to add custom logic when trades are opened.
        """
        pass
    
    def on_trade_closed(self, trade: 'Trade', context: StrategyContext) -> None:
        """
        Called when a trade is closed.
        
        Override this method to add custom logic when trades are closed.
        """
        pass
    
    def on_candle_processed(self, context: StrategyContext) -> None:
        """
        Called after each candle is processed.
        
        Override this method to maintain internal state or perform cleanup.
        """
        pass


class IndicatorCalculator(ABC):
    """
    Abstract base class for technical indicator calculators.
    
    Indicators can be plugged into the system and calculated automatically
    for strategies that require them.
    """
    
    @abstractmethod
    def get_name(self) -> str:
        """Return indicator name."""
        pass
    
    @abstractmethod
    def calculate(self, candles: List[Candle], **kwargs) -> Dict[datetime, float]:
        """
        Calculate indicator values for given candles.
        
        Args:
            candles: Historical candle data
            **kwargs: Additional parameters for indicator calculation
            
        Returns:
            Dict[datetime, float]: Mapping of timestamp to indicator value
        """
        pass
    
    @abstractmethod
    def requires_periods(self) -> int:
        """
        Return minimum number of periods required for calculation.
        
        Returns:
            int: Minimum number of candles needed for reliable calculation
        """
        pass


@dataclass 
class BacktestConfiguration:
    """
    Configuration for backtesting runs.
    """
    symbol: str
    start_date: str
    end_date: str
    timeframe: str
    stop_loss_pips: float = 10.0
    take_profit_pips: float = 15.0
    initial_balance: float = 10000.0
    risk_per_trade: float = 0.02  # 2% risk per trade
    max_open_trades: int = 1
    commission_per_trade: float = 0.0
    
    def __post_init__(self):
        """Validate configuration parameters."""
        if self.stop_loss_pips <= 0:
            raise ValueError("Stop loss must be positive")
        if self.take_profit_pips <= 0:
            raise ValueError("Take profit must be positive")
        if self.initial_balance <= 0:
            raise ValueError("Initial balance must be positive")
        if not (0 < self.risk_per_trade <= 1):
            raise ValueError("Risk per trade must be between 0 and 1")


@dataclass
class BacktestResults:
    """
    Standardized results from backtesting any strategy.
    
    This ensures all strategies return consistent, comparable results.
    """
    strategy_name: str
    strategy_version: str
    configuration: BacktestConfiguration
    
    # Trade results
    trades: List['Trade']
    total_trades: int
    winning_trades: int
    losing_trades: int
    
    # Performance metrics
    total_pips: float
    win_rate: float
    profit_factor: float
    average_win: float
    average_loss: float
    largest_win: float
    largest_loss: float
    
    # Risk metrics
    max_drawdown: float
    max_consecutive_losses: int
    max_consecutive_wins: int
    
    # Timing
    start_time: datetime
    end_time: datetime
    execution_time_seconds: float
    
    # Data source info
    data_source: str
    total_candles_processed: int
    
    # Market data (for chart generation)
    market_data: Optional[List['Candle']] = None
    
    def to_dict(self, include_market_data: bool = True) -> Dict[str, Any]:
        """Convert results to dictionary for JSON serialization."""
        result = {
            "strategy_name": self.strategy_name,
            "strategy_version": self.strategy_version,
            "configuration": self.configuration.__dict__,
            "trades": [
                {
                    "entry_time": trade.entry_time.isoformat(),
                    "exit_time": trade.exit_time.isoformat() if trade.exit_time else None,
                    "direction": trade.direction.name,
                    "entry_price": trade.entry_price,
                    "exit_price": trade.exit_price,
                    "pips": trade.pips,
                    "result": trade.result.name if trade.result else "PENDING"
                } for trade in self.trades
            ],
            "summary": {
                "total_trades": self.total_trades,
                "winning_trades": self.winning_trades,
                "losing_trades": self.losing_trades,
                "win_rate": self.win_rate,
                "total_pips": self.total_pips,
                "profit_factor": self.profit_factor,
                "average_win": self.average_win,
                "average_loss": self.average_loss,
                "largest_win": self.largest_win,
                "largest_loss": self.largest_loss,
            },
            "risk_metrics": {
                "max_drawdown": self.max_drawdown,
                "max_consecutive_losses": self.max_consecutive_losses,
                "max_consecutive_wins": self.max_consecutive_wins,
            },
            "execution": {
                "start_time": self.start_time.isoformat(),
                "end_time": self.end_time.isoformat(),
                "execution_time_seconds": self.execution_time_seconds,
                "data_source": self.data_source,
                "total_candles_processed": self.total_candles_processed,
            }
        }
        
        # Include market data if requested
        if include_market_data and hasattr(self, 'market_data'):
            result["market_data"] = [
                {
                    "timestamp": candle.timestamp.isoformat(),
                    "open": candle.open,
                    "high": candle.high,
                    "low": candle.low,
                    "close": candle.close,
                    "volume": candle.volume
                } for candle in self.market_data
            ]
            
        return result