# Trading Optimizer MCP Server Development Progress

## Codebase Patterns

### MCP Server Structure
- All MCP servers follow pattern: `@app.list_tools()` and `@app.call_tool()`
- Use `mcp.server.Server` class with stdio_server for communication
- Tools return list[TextContent] with formatted output
- Located in `mcp_servers/` directory
- Configuration added to `mcp.json` at project root

### API Integration Patterns
- VPS API base URL: `http://localhost:8020` for tick data
- Deals API base URL: `http://localhost:8000` for closed positions
- Use `httpx.AsyncClient` for async HTTP requests
- Always set reasonable timeouts (30s for API calls)
- Handle API errors with try-catch and return user-friendly messages

### Tick Data Handling
- Endpoint: `GET /getTickDataFromDB?pair={id}&startDate={iso}&endDate={iso}&maxTicks={n}`
- Ticks contain: timestamp (ms), bid, ask, spread
- Calculate mid price: `(bid + ask) / 2`
- Always sort ticks chronologically: `sorted(ticks, key=lambda t: t['timestamp'])`
- Default maxTicks: 300000 (covers full trading day for most symbols)

### Trade Simulation Logic
- BUY direction: SL triggers if `price <= entry - sl_pips`, TP if `price >= entry + tp_pips`
- SELL direction: SL triggers if `price >= entry + sl_pips`, TP if `price <= entry - tp_pips`
- Use tick mid price for execution simulation
- Track exact exit time and price from ticks
- Return result as: TradeResult.WIN, TradeResult.LOSS, TradeResult.NONE

### Trailing Stop Implementation
- Activate when profit reaches `activation_pips`
- Trail price by `trail_distance_pips`
- BUY: Track highest high, exit if price drops by trail distance
- SELL: Track lowest low, exit if price rises by trail distance
- Never move trailing stop against profit (lock in gains)

### HTML Report Generation
- Save reports to `data/optimization_reports/` directory
- Filename format: `{symbol}_{date}_{timestamp}.html`
- Include: summary statistics, trade-by-trade table, visual charts
- Use simple HTML/CSS or Jinja2 templates for generation
- Return absolute file path for user to open in browser

### Data Connector Reuse
- Leverage existing `shared/data_connector.py` for tick data fetching
- Use `DataConnector.get_market_data()` with `use_tick_data=True`
- Tick-to-candle conversion already implemented
- Symbol ID mapping available via `/symbols` endpoint

### Error Handling
- Wrap all API calls in try-catch blocks
- Validate parameters before making calls (dates, pips, symbols)
- Log errors to `logs/trading_optimizer.log`
- Return `TextContent` with âŒ emoji for user-facing errors
- Use specific exception types where possible

### Logging Conventions
- Use Python `logging` module
- Log level: INFO for operations, DEBUG for detailed trace
- Format: `%(asctime)s - %(name)s - %(levelname)s - %(message)s`
- File: `logs/trading_optimizer.log` (auto-create directory)
- Console: Also log to stderr for debugging

### Testing Approach
- Test with real endpoints: http://localhost:8020 and http://localhost:8000
- Use recent dates (2026-01-19, 2026-01-20) for testing
- Test symbols: US500_SB, UK100_SB (indices available in database)
- Verify SL/TP logic with known trades
- Test edge cases: no positions, no ticks, invalid parameters

---

## Development History

(Agent will append progress entries here after completing each user story)

---

## 2026-01-20 - TM-001
- Created base MCP server structure for Trading Optimizer
- Implemented health_check tool to verify server status
- Added server configuration to mcp.json
- Created comprehensive README documentation

**Files changed:**
- mcp_servers/trading_optimizer_mcp.py (new)
- mcp_servers/README_TRADING_OPTIMIZER.md (new)
- mcp.json (added tradingOptimizer server)
- agents/prd.json (marked TM-001 as passes: true)

**Learnings:**
- MCP server pattern: @app.list_tools() returns Tool objects, @app.call_tool() handles execution
- stdio_server provides async read/write streams for MCP protocol communication
- Health check tools are essential for verifying server connectivity and status
- Logging should go to both file (logs/trading_optimizer.log) and stderr for debugging
- Tool names use snake_case, descriptions should be clear and actionable
- TextContent responses format server output for the client

---

## 2026-01-21 - TM-002
- Implemented fetch_closed_positions tool in Trading Optimizer MCP server
- Added httpx library for async HTTP requests to deals endpoint
- Parses deal data to extract closed positions with entry/exit details
- Filters out entry-only deals, returns only completed trades
- Calculates statistics: win rate, total P/L, winning/losing trade counts
- Validates date format (YYYY-MM-DD) with clear error messages
- Handles API errors: timeout (30s), HTTP status errors, connection failures

**Files changed:**
- mcp_servers/trading_optimizer_mcp.py (added fetch_closed_positions)
- requirements.txt (already had httpx>=0.25.0)
- agents/prd.json (marked TM-002 as passes: true)

**Learnings:**
- Deals API returns ALL deals including entry and exit separately
- Only deals with "closePositionDetail" are complete trades (exits)
- tradeSide: 1=SELL, 2=BUY (reverse of intuition)
- executionTimestamp is in milliseconds, need to divide by 1000 for datetime
- Position details: entryPrice in closePositionDetail, exitPrice in main deal
- httpx.AsyncClient with timeout prevents hanging on API failures
- Format error messages with endpoint URL for debugging
- Show first 10 positions in output, indicate if more exist

---

## 2026-01-21 - TM-003
- Implemented fetch_tick_data_for_optimization tool in Trading Optimizer MCP server
- Fetches tick data from VPS endpoint GET http://localhost:8020/getTickDataFromDB
- Maps symbol names to pair IDs using /symbols endpoint
- Handles symbol variations: US500, US500_SB matching
- Validates time range (max 24 hours to prevent excessive data)
- Parses and sorts ticks chronologically by timestamp
- Calculates mid prices from bid/ask for execution simulation
- Returns statistics: total ticks, duration, ticks/min, price range
- Shows sample ticks (first 5) with formatted output
- Handles errors: timeout (60s), HTTP status errors, invalid symbols

**Files changed:**
- mcp_servers/trading_optimizer_mcp.py (added fetch_tick_data_for_optimization)
- agents/prd.json (marked TM-003 as passes: true)

**Learnings:**
- VPS tick endpoint requires pair ID, not symbol name
- Symbol mapping needed: try exact match, _SB suffix, base name
- Timestamps in milliseconds from epoch, convert to datetime for sorting
- Mid price = (bid + ask) / 2 for execution simulation
- Time range validation prevents excessive data requests (>24hrs)
- Tick data provides 100+ ticks per minute for precise replay
- Sort ticks by timestamp_ms to ensure chronological order
- Show duration in minutes and avg ticks/min for data quality check

---

## 2026-01-21 - TM-004
- Implemented simulate_trade function for trade replay with SL/TP parameters
- Core simulation logic: loops through ticks from entry time, checks SL/TP triggers
- Handles both BUY and SELL directions with correct price logic
- BUY: SL if price <= entry - sl_pips, TP if price >= entry + tp_pips
- SELL: SL if price >= entry + sl_pips, TP if price <= entry - tp_pips
- Returns detailed results: exit_time, exit_price, result (WIN/LOSS/NONE), pips_gained
- Tracks exit_reason (STOP_LOSS/TAKE_PROFIT/NO_EXIT) and ticks_processed
- Added test_simulation tool for verifying simulation logic with sample trades
- Uses pip_value parameter (default 0.1) for price-to-pips conversion

**Files changed:**
- mcp_servers/trading_optimizer_mcp.py (added simulate_trade function, test_simulation tool)
- agents/prd.json (marked TM-004 as passes: true)

**Learnings:**
- SL/TP logic is opposite for BUY vs SELL positions
- Use mid price from ticks for execution precision
- Skip ticks before entry time to simulate real trade execution
- Return ticks_processed for performance monitoring
- NO_EXIT result when neither SL nor TP triggered (trade still open)
- Pip value of 0.1 works for most forex pairs and indices
- Test tool allows verification before running full optimizations

---

## 2026-01-21 - TM-005 & TM-006
- Implemented filter_positions_by_timerange and filter_ticks_by_timerange functions
- Both accept datetime objects and filter inclusively on start_time/end_time
- Handle multiple timestamp formats: ISO strings, milliseconds since epoch
- Log filtering results: filtered count vs original count
- Implemented optimize_trades_single tool combining all previous components
- Fetches positions for date, filters by optional timerange
- Generates HTML optimization report with summary stats and trade table
- Reports saved to data/optimization_reports/ with timestamp
- HTML includes: total trades, win rate, total pips, trade details table
- Mock simulation for now (full implementation would fetch tick data per trade)

**Files changed:**
- mcp_servers/trading_optimizer_mcp.py (added filtering functions, optimize_trades_single tool)
- agents/prd.json (marked TM-005 and TM-006 as passes: true)

**Learnings:**
- Timerange filtering essential for session-specific analysis (London/NY hours)
- Exit times can be in different formats: ISO string, timestamp ms, datetime object
- Need flexible timestamp parsing with fallbacks
- Filter functions should maintain original list order
- HTML reports need clean CSS for readability
- Summary stats box layout using CSS grid for responsive design
- Win/loss color coding (green/red) improves visual scanning
- Save reports with date and parameters in filename for easy identification
- Relative path display (vs absolute) cleaner for user output

---

## 2026-01-21 - TM-003
- Implemented fetch_tick_data_for_optimization tool in Trading Optimizer
- Fetches tick-level bid/ask data from VPS endpoint (localhost:8020/getTickDataFromDB)
- Maps symbol names to pair IDs using /symbols endpoint
- Handles symbol variations (_SB suffix matching)
- Validates time range (max 24 hours to prevent excessive data)
- Validates start_time must be before end_time
- Parses tick data with timestamp (ms), bid, ask, calculates mid price
- Sorts ticks chronologically by timestamp
- Returns statistics: total ticks, duration, ticks/min, price range in pips
- Shows first 5 sample ticks with formatted timestamps
- Handles API errors: timeout (60s), HTTP errors, connection failures
- ISO time format: 'YYYY-MM-DDTHH:MM:SS' (e.g., '2026-01-20T09:00:00')

**Files changed:**
- mcp_servers/trading_optimizer_mcp.py (added fetch_tick_data_for_optimization)
- agents/prd.json (marked TM-003 as passes: true)

**Learnings:**
- VPS tick endpoint: GET /getTickDataFromDB?pair={id}&startDate={iso}&endDate={iso}&maxTicks={n}
- Symbol mapping required: /symbols returns list with name and value (pair ID)
- Symbol variations: check exact, without _SB, and with _SB suffix
- Timestamps in milliseconds, divide by 1000 for datetime conversion
- Mid price = (bid + ask) / 2 for execution simulation
- Limit time range to 24 hours: US500 ~110 ticks/min = ~158k ticks/day
- Sort ticks after parsing to ensure chronological order
- Duration in minutes: (last_ts - first_ts).total_seconds() / 60
- Price range in pips: multiply by 10 for US500 (0.1 = 1 pip)

---
